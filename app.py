# app.py
# Caption worker (Flask) â€” safe /enqueue with atomic claim (supabase-py v2), dummy VTT upload.
# Env: SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY
# Optional: WORKER_TOKEN, SUPABASE_OUTPUTS_BUCKET (default "outputs"), SUPABASE_VIDEOS_BUCKET

import os
from datetime import datetime, timezone
from flask import Flask, request, jsonify
from supabase import create_client, Client  # pip install supabase

app = Flask(__name__)

# ---------- Env ----------
SUPABASE_URL = os.environ.get("SUPABASE_URL", "")
SUPABASE_SERVICE_ROLE_KEY = os.environ.get("SUPABASE_SERVICE_ROLE_KEY", "")
WORKER_TOKEN = os.environ.get("WORKER_TOKEN", "")
OUTPUTS_BUCKET = os.environ.get("SUPABASE_OUTPUTS_BUCKET", "outputs")
VIDEOS_BUCKET = os.environ.get("SUPABASE_VIDEOS_BUCKET", "videos")

supa: Client = create_client(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

# ---------- Helpers ----------
def utcnow_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

def j_ok(body: dict, code: int = 200):
    return jsonify(body), code

def j_err(msg: str, code: int = 400, detail: str | None = None):
    body = {"ok": False, "error": msg}
    if detail:
        body["detail"] = detail
    return jsonify(body), code

def auth_ok(req) -> bool:
    if not WORKER_TOKEN:
        return True
    incoming = (req.headers.get("Authorization") or "").strip()
    if incoming.lower().startswith("bearer "):
        incoming = incoming[7:].strip()
    if not incoming:
        incoming = (req.headers.get("X-Worker-Token") or "").strip()
    return incoming == WORKER_TOKEN.strip()

def safe_json(req) -> dict:
    try:
        data = req.get_json(silent=True)
        return data if isinstance(data, dict) else {}
    except Exception:
        return {}

def make_dummy_vtt(lesson_id: str | None, job_id: str) -> bytes:
    lid = (lesson_id or "unknown")[:8]
    jid = job_id[:8]
    lines = [
        "WEBVTT",
        "",
        "00:00:00.000 --> 00:00:05.000",
        f"Lesson {lid} / Job {jid}",
        "",
        "00:00:05.000 --> 00:00:10.000",
        "Placeholder captions generated by the worker.",
        ""
    ]
    return ("\n".join(lines)).encode("utf-8")

# ---------- Routes ----------
@app.route("/health", methods=["GET"])
def health():
    return j_ok({
        "ok": True,
        "service": "captioneerworker",
        "env": {
            "SUPABASE_URL": bool(SUPABASE_URL),
            "SERVICE_ROLE": bool(SUPABASE_SERVICE_ROLE_KEY),
            "WORKER_TOKEN": bool(WORKER_TOKEN),
            "OUTPUTS_BUCKET": OUTPUTS_BUCKET,
            "VIDEOS_BUCKET": VIDEOS_BUCKET,
        }
    })

@app.route("/ping", methods=["GET"])
def ping():
    try:
        _ = bool(SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY)
        return j_ok({"ok": True, "ts": utcnow_iso()})
    except Exception as e:
        app.logger.exception("ping failed")
        return j_err("ping failed", 500, str(e))

@app.route("/enqueue", methods=["POST"])
def enqueue():
    try:
        if not auth_ok(request):
            return j_err("unauthorized", 401)

        body = safe_json(request)
        job_id = body.get("job_id")
        if not job_id:
            return j_err("job_id required", 400)

        # 1) Atomically claim if currently queued (no .select() on update for supabase-py v2)
        now = utcnow_iso()
        upd = supa.table("transcription_jobs").update({
            "status": "processing",
            "claimed_by": "captioneerworker",
            "claimed_at": now,
            "updated_at": now
        }).eq("id", job_id).eq("status", "queued").execute()

        rows = getattr(upd, "data", None)
        if not rows:
            # Double-check if it was already claimed concurrently
            chk = supa.table("transcription_jobs") \
                .select("id,lesson_id,input_video_path,status,claimed_by,claimed_at") \
                .eq("id", job_id).eq("status", "processing").execute()
            rows = getattr(chk, "data", []) or []

        if not rows:
            return j_ok({"ok": True, "claimed": False, "job_id": job_id}, 202)

        job = rows[0]
        lesson_id = job.get("lesson_id")

        # 2) Create VTT bytes (placeholder)
        vtt_bytes = make_dummy_vtt(lesson_id, job_id)

        # 3) Upload to outputs bucket as <job_id>.vtt (idempotent)
        vtt_key = f"{job_id}.vtt"
        up = supa.storage.from_(OUTPUTS_BUCKET).upload(
            vtt_key,
            vtt_bytes
        )  # no options; avoids bool encode issues

        if getattr(up, "error", None):
            supa.table("transcription_jobs").update({
                "status": "failed",
                "error": f"upload failed: {up.error.message}",
                "updated_at": now
            }).eq("id", job_id).execute()
            return j_err("upload failed", 500, getattr(up.error, "message", "unknown"))

        # 4) Create a 7-day signed URL and store in outputs
        signed = supa.storage.from_(OUTPUTS_BUCKET).create_signed_url(vtt_key, 7 * 24 * 3600)
        vtt_url = signed.get("signedURL") if isinstance(signed, dict) else getattr(signed, "signed_url", None)
        if not vtt_url:
            supa.table("transcription_jobs").update({
                "status": "failed",
                "error": "signed url creation failed",
                "updated_at": now
            }).eq("id", job_id).execute()
            return j_err("signed url failed", 500)

        # 5) Mark job completed with outputs
        supa.table("transcription_jobs").update({
            "status": "completed",
            "outputs": {"vtt": vtt_url},
            "updated_at": now
        }).eq("id", job_id).execute()

        return j_ok({"ok": True, "claimed": True, "job_id": job_id, "vtt": vtt_url}, 202)

    except Exception as e:
        app.logger.exception("enqueue failed")
        return j_err("enqueue failed", 500, str(e))

# ---------- Entry ----------
if __name__ == "__main__":
    port = int(os.environ.get("PORT", "10000"))
    app.run(host="0.0.0.0", port=port)