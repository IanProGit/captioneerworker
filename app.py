# app.py
# Caption worker (Flask) â€” safe /enqueue with atomic job claim and VTT output.
# Requires env: SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, WORKER_TOKEN (optional),
# SUPABASE_OUTPUTS_BUCKET (default "outputs"), SUPABASE_VIDEOS_BUCKET (optional).

import os
import json
from datetime import datetime, timezone
from flask import Flask, request, jsonify

# pip install supabase
from supabase import create_client, Client

app = Flask(__name__)

# ---------- Environment ----------
SUPABASE_URL = os.environ.get("SUPABASE_URL", "")
SUPABASE_SERVICE_ROLE_KEY = os.environ.get("SUPABASE_SERVICE_ROLE_KEY", "")
WORKER_TOKEN = os.environ.get("WORKER_TOKEN", "")

OUTPUTS_BUCKET = os.environ.get("SUPABASE_OUTPUTS_BUCKET", "outputs")
VIDEOS_BUCKET = os.environ.get("SUPABASE_VIDEOS_BUCKET", "videos")  # optional/informational

if not SUPABASE_URL or not SUPABASE_SERVICE_ROLE_KEY:
    app.logger.error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY")

supa: Client = create_client(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)


# ---------- Helpers ----------
def utcnow_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

def ok(body: dict, code: int = 200):
    return jsonify(body), code

def err(msg: str, code: int = 400, detail: str | None = None):
    body = {"ok": False, "error": msg}
    if detail:
        body["detail"] = detail
    return jsonify(body), code

def auth_ok(req) -> bool:
    """Accept Bearer token, raw Authorization, or X-Worker-Token."""
    if not WORKER_TOKEN:
        return True
    incoming = (req.headers.get("Authorization") or "").strip()
    if incoming.lower().startswith("bearer "):
        incoming = incoming[7:].strip()
    if not incoming:
        incoming = (req.headers.get("X-Worker-Token") or "").strip()
    return incoming == WORKER_TOKEN.strip()

def safe_json(req) -> dict:
    try:
        data = req.get_json(silent=True)
        return data if isinstance(data, dict) else {}
    except Exception:
        return {}

def make_dummy_vtt(lesson_id: str | None, job_id: str) -> bytes:
    """Generate a minimal valid VTT so the pipeline advances.
       Replace with real transcription when ready."""
    lid = (lesson_id or "unknown")[:8]
    jid = job_id[:8]
    lines = [
        "WEBVTT",
        "",
        "00:00:00.000 --> 00:00:05.000",
        f"Lesson {lid} / Job {jid}",
        "",
        "00:00:05.000 --> 00:00:09.000",
        "Placeholder captions generated by the worker.",
        ""
    ]
    return ("\n".join(lines)).encode("utf-8")


# ---------- Routes ----------
@app.route("/health", methods=["GET"])
def health():
    return ok({
        "ok": True,
        "service": "captioneerworker",
        "env": {
            "SUPABASE_URL": bool(SUPABASE_URL),
            "SERVICE_ROLE": bool(SUPABASE_SERVICE_ROLE_KEY),
            "WORKER_TOKEN": bool(WORKER_TOKEN),
            "OUTPUTS_BUCKET": OUTPUTS_BUCKET,
            "VIDEOS_BUCKET": VIDEOS_BUCKET,
        }
    })

@app.route("/ping", methods=["GET"])
def ping():
    try:
        _ = bool(SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY)
        return ok({"ok": True, "ts": utcnow_iso()})
    except Exception as e:
        app.logger.exception("ping failed")
        return err("ping failed", 500, str(e))

@app.route("/enqueue", methods=["POST"])
def enqueue():
    try:
        if not auth_ok(request):
            return err("unauthorized", 401)

        body = safe_json(request)
        job_id = body.get("job_id")
        if not job_id:
            return err("job_id required", 400)

        # 1) Atomically claim the job if it's currently queued
        now = utcnow_iso()
        # Update + return row in a single round trip; do NOT use .single() on a plain select
        res = supa.table("transcription_jobs").update({
            "status": "processing",
            "claimed_by": "captioneerworker",
            "claimed_at": now,
            "updated_at": now
        }).eq("id", job_id).eq("status", "queued") \
         .select("id, lesson_id, input_video_path").execute()

        rows = getattr(res, "data", []) or []
        if not rows:
            # Nothing to claim (wrong id, already claimed/processed, or not queued)
            return ok({"ok": True, "claimed": False, "job_id": job_id}, 202)

        job = rows[0]
        lesson_id = job.get("lesson_id")

        # 2) Produce VTT (placeholder). Swap this for real STT when ready.
        vtt_bytes = make_dummy_vtt(lesson_id, job_id)

        # 3) Upload VTT to outputs bucket as <job_id>.vtt (idempotent via upsert)
        vtt_key = f"{job_id}.vtt"
        up = supa.storage.from_(OUTPUTS_BUCKET).upload(
            vtt_key, vtt_bytes,
            {"contentType": "text/vtt", "upsert": True}
        )
        if getattr(up, "error", None):
            supa.table("transcription_jobs").update({
                "status": "failed",
                "error": f"upload failed: {up.error.message}",
                "updated_at": now
            }).eq("id", job_id).execute()
            return err("upload failed", 500, getattr(up.error, "message", "unknown"))

        # 4) Create a 7-day signed URL for the VTT and store in outputs
        signed = supa.storage.from_(OUTPUTS_BUCKET).create_signed_url(vtt_key, 7 * 24 * 3600)
        vtt_url = signed.get("signedURL") if isinstance(signed, dict) else getattr(signed, "signed_url", None)
        if not vtt_url:
            supa.table("transcription_jobs").update({
                "status": "failed",
                "error": "signed url creation failed",
                "updated_at": now
            }).eq("id", job_id).execute()
            return err("signed url failed", 500)

        # 5) Mark job completed with outputs
        supa.table("transcription_jobs").update({
            "status": "completed",
            "outputs": {"vtt": vtt_url},
            "updated_at": now
        }).eq("id", job_id).execute()

        return ok({"ok": True, "claimed": True, "job_id": job_id, "vtt": vtt_url}, 202)

    except Exception as e:
        app.logger.exception("enqueue failed")
        # Never crash; always return JSON
        return err("enqueue failed", 500, str(e))


# ---------- Entry ----------
if __name__ == "__main__":
    port = int(os.environ.get("PORT", "10000"))
    app.run(host="0.0.0.0", port=port)